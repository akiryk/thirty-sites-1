# Thirty For Thirty

My plan is to make thirty sites in which I recreate effects I've seen elsewhere on the internet. They might be cool effects or simply challenging or interesting effects — mainly, it's a way for me to learn a few things I don't otherwise have the opportunity to explore.

## Today's site: Distortion

*Only tested on Chrome.*

[Distortion](https://akiryk.github.io/thirty-sites-1/index.html), based on [xtian.design](http://xtian.design/)

xtian.design does a few things I thought would be fun to figure out.

* Animate distortion effects on an image
* Break headlines in half
* Seamlessly reset scrolling once you reach the bottom
* Animate a fancy little loading circle

The xtian site uses several javascript libraries including [Pixi.js](http://pixijs.io/), [GSAP](https://greensock.com/gsap), [ScrollMagic](http://scrollmagic.io/docs/index.html), [jQuery](https://jquery.com/), and one or more jQuery plugins — I believe for taking over scrolling and handling scroll momentum.

## How to distort an image

The effect on xtian.design is achieved by animating a displacement filter, in this case, an image of clouds generated by Photoshop or something similar. I won't explain how to use Pixi here, but the basic steps are:

1. Load a main images and a clouds image into Pixi sprites
2. Create a new displacement filter using the clouds image.
3. Set the strength of the filter using scale x and y parameters.
4. Enable a Pixi 'ticker' or game loop to animate the clouds image, say, by having it rotate endlessly. This creates the initial distortion animation you see when the site loads.

This is a [useful demo](http://pixijs.io/pixi-filters/tools/demo/) for learning about Pixi filters.

## How to animate the amount of distortion on an image

Changing the filter's scale properties based on scroll position is handled by ScrollMagic and GSAP (TweenLite).
```JavaScript
    // Get a reference to the Pixi displacement filter's scale
    const scaleObj = this.displacementFilter.scale;

    // Create a GSAP tween that uses the filter scale
    // In this case, I'm animating from the default scale of 150 or so down to zero.
    const distortionTween = TweenLite.to(scaleObj, .85, {x: 0, y: 0});

    // Create a ScrollMagic Scene and set the distortionTween based on whatever trigger you want.
    new ScrollMagic.Scene({ // etc. etc
```

## How to break headlines in half

Create three copies of the same headline, `class="headline-top"`, `class="headline-bottom"` and `class="headline-guide` and put them in container with `position: relative`.

For headlines top and bottom:
```CSS
    position: absolute;
    height: 56%;
    width: 100%;
    overflow: hidden;
```

Put the text for headline-bottom in a span element. Then style that span so it's offset.
```CSS
    display: block;
    position: absolute;
    top: -100%;
    left: 0;
    width: 100%;
    height: 100%;
```

For the guide headline, set `visibility: hidden` This way, you won't see the guide but it will occupy space and prevent the absolutely positioned half-headlines from collapsing.

Alternatively, use clip-path to make the two headlines display top and bottom. I used this method for the End headline.

```CSS
    .end-headline--top {
      clip-path: inset(0 0 50% 0);
    }

    .end-headline--bottom {
      clip-path: inset(50% 0 0 0);
    }
```

Animating the halves is simply a matter of creating ScrollMagic scenes that tween rotation, x, and y properties.

## Create a fancy little loader.

Check out [my pen here](https://codepen.io/akiryk/pen/KQPYBW).

## How to scroll seamlessly

I didn't really figure this out except to see that it requires taking control of scrolling away from the user. I tried to do it without, but the native scroll really doesn't like being jerked around like that.

Two of the steps are:

1. Create a clone of the intro headline and place it at the end of the page content.
2. Track the y position of the two headlines relative to the page, and when the clone version reaches the place where the original version started use scrollTo() and go back to the top. Endless scrolling.

Here's some psuedo-ish code that starts to do that.

```JavaScript
    const startY = getYPosition(originalHeadline);

    /**
     * @description Get the y position of an element
     * @param {element}
     * @return {number} yPos
     */
    getYPosition(el) {
      let yPos = 0;
      while(el) {
        yPos += (el.offsetTop - el.scrollTop + el.clientTop);
        el = el.offsetParent;
      }
      return yPos;
    }

    const scene = new ScrollMagic.Scene().addTo(controller)

    // On scene update, check location of the two headlines and scroll direction.
    scene.on('update', function(event) {
        const dir = controller.info('scrollDirection');
        const cloneY = clone.getBoundingClientRect().top;
        const introY = intro.getBoundingClientRect().top;
        if (cloneY <= startY){
          const diff = startY - cloneY;
          resetTitleStyles();
          window.scroll(0,diff);
        }
        if (dir === 'REVERSE' && ceiling(introY) >= startY) {
          resetTitleStyles();
          window.scroll(0, cloneY - startY);
        }
      });
```
